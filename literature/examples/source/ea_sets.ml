
(* =========================================================================================== *)
(* Mengen als echt absteigende Listen                                                          *)
(* =========================================================================================== *)

type 'a set = 'a list;;

(* ------------------------------------------------------------------------------------------- *)
(* insert x s liefert s \cup {x}                                                               *)
(* ------------------------------------------------------------------------------------------- *)

let rec insert (x: 'a) (s: 'a set): 'a set =
  match s with 
      [] -> [x]
    | y :: s' -> 
	match compare x y with 
	    0 -> s
	  | 1 -> x :: s
	  | _ -> y :: insert x s';;

(* ------------------------------------------------------------------------------------------- *)
(* delete x s liefert s \setminus x                                                            *)
(* ------------------------------------------------------------------------------------------- *)

let rec delete (x: 'a) (s: 'a set): 'a set = 
  match s with 
      [] -> []
    | y :: s' ->
	match compare x y with 
	    0 -> s'
	  | 1 -> s
	  | _ -> y :: delete x s';;

(* ------------------------------------------------------------------------------------------- *)
(* mk_set l liefert die Menge aller Elemente der Liste l                                       *)
(* ------------------------------------------------------------------------------------------- *)

let rec mk_set (l: 'a list): 'a set = 
  match l with 
      [] -> []
    | x :: l' -> insert x (mk_set l');;

(* ------------------------------------------------------------------------------------------- *)
(* member x s testet, ob x \in s                                                               *)
(* ------------------------------------------------------------------------------------------- *)

let rec member (x: 'a) (s: 'a set): bool =
  match s with 
      [] -> false 
    | y :: s' -> 
	match compare x y with 
	    0 -> true
	  | 1 -> false 
	  | _ -> member x s';;

(* ------------------------------------------------------------------------------------------- *)
(* meet s1 s2 testet, ob s1 \cap s2 <> \emptyset                                               *)
(* ------------------------------------------------------------------------------------------- *)

let rec meet (s1: 'a set) (s2: 'a set): bool = 
  match s1, s2 with 
      [], _ | _, [] -> false 
    | x :: s1', y :: s2' ->
	match compare x y with 
	    0 -> true
	  | 1 -> meet s1' s2 
	  | _ -> meet s1 s2';;

(* ------------------------------------------------------------------------------------------- *)
(* subset s1 s2 überprüft, ob s1 \sleq s2                                                      *)
(* ------------------------------------------------------------------------------------------- *)

let rec subset (s1: 'a set) (s2: 'a set): bool =
  match s1, s2 with 
      [], _ -> true
    | _, [] -> false 
    | x :: s1', y :: s2' ->
	match compare x y with 
	    0 -> subset s1' s2'
	  | 1 -> false 
	  | _ -> subset s1 s2';;

(* ------------------------------------------------------------------------------------------- *)
(* union s1 s2 liefert s1 \cup s2                                                              *)
(* ------------------------------------------------------------------------------------------- *)

let rec union (s1: 'a set) (s2: 'a set): 'a set = 
  match s1, s2 with 
      [], _ -> s2
    | _, [] -> s1 
    | x :: s1', y :: s2' -> 
	match compare x y with 
	    0 -> x :: union s1' s2'
	  | 1 -> x :: union s1' s2
	  | _ -> y :: union s1 s2';;

(* ------------------------------------------------------------------------------------------- *)
(* big_union [s_1; ...; s_n] liefert \bigcup_{i=1}^n s_i [s_1; ...; s_n]                       *)
(* ------------------------------------------------------------------------------------------- *)

let rec big_union (l: 'a set list): 'a set =
 match l with 
     [] -> []
   | s :: l' -> union s (big_union l');;

(* ------------------------------------------------------------------------------------------- *)
(* intersection s1 s2 liefert s1 \cap s2                                                       *)
(* ------------------------------------------------------------------------------------------- *)

let rec intersection (s1: 'a set) (s2: 'a set): 'a set = 
  match s1, s2 with 
      [], _ -> []
    | _, [] -> [] 
    | x :: s1', y :: s2' -> 
	match compare x y with 
	    0 -> x :: intersection s1' s2'
	  | 1 -> intersection s1' s2
	  | _ -> intersection s1 s2';;

(* ------------------------------------------------------------------------------------------- *)
(* difference s1 s2 liefert s1 \setminus s2                                                    *)
(* ------------------------------------------------------------------------------------------- *)

let rec difference (s1: 'a set) (s2: 'a set): 'a set = 
  match s1, s2 with 
      [], _ -> []
    | _, [] -> s1 
    | x :: s1', y :: s2' ->
	match compare x y with 
	    0 -> difference s1' s2' 
	  | 1 -> x :: difference s1' s2
	  | _ -> difference s1 s2';;

(* ------------------------------------------------------------------------------------------- *)
(* map f s liefert f(s) = {f x | x \in s}                                                      *)
(* ------------------------------------------------------------------------------------------- *)

let map (f: 'a -> 'b) (s: 'a set): 'b set = 
  mk_set (List.map f s);;

(* ------------------------------------------------------------------------------------------- *)
(* filter p s liefert die Menge {x \in s | p x}                                                *)
(* ------------------------------------------------------------------------------------------- *)

let filter: ('a -> bool) -> 'a set -> 'a set =
  List.filter;;

(* ------------------------------------------------------------------------------------------- *)
(* product s1 s2 liefert s1 \times s2 (mit der lexikographischen Ordnung)                      *)
(* ------------------------------------------------------------------------------------------- *)

let product (s1: 'a set) (s2: 'b set): ('a * 'b) set = 
  List.flatten (List.map (fun a -> List.map (fun b -> a, b) s2) s1);;


(* =========================================================================================== *)
(* Relationen als Mengen (mit der lexikographischen Ordnung)                                   *)
(* =========================================================================================== *)

type ('a, 'b) relation = ('a * 'b) set;;

(* ------------------------------------------------------------------------------------------- *)
(* graph f s liefert den Graph von f|s, also die Menge {(x, f x) | x \in s}                    *)
(* ------------------------------------------------------------------------------------------- *)

let graph (f: 'a -> 'b) (s: 'a set): ('a, 'b) relation = 
  map (fun x -> x, f x) s;;

(* ------------------------------------------------------------------------------------------- *)
(* mk_function r liefert die "mengenwertige" Funktion f mit f x = {y | (x, y) \in r}           *)
(* ------------------------------------------------------------------------------------------- *)

let mk_function (r: ('a, 'b) relation) (x: 'a): 'b set = 
  List.map snd (filter (fun (x', _) -> x' = x) r);;
  
(* ------------------------------------------------------------------------------------------- *)
(* image r s liefert liefert das Bild r(s) = {y | \exists x \in s. (x, y) \in r}               *)
(* ------------------------------------------------------------------------------------------- *)

let image (r: ('a, 'b) relation) (s: 'a set): 'b set = 
  big_union (map (mk_function r) s);;

let inverse (r: ('a, 'b) relation): ('b, 'a) relation = 
  map (fun (x, y) -> y, x) r;;

let preimage (r: ('a, 'b) relation) (s: 'b set): 'a set =
  image (inverse r) s;;

(* ------------------------------------------------------------------------------------------- *)
(* nats_upto n liefert die Menge {i \in N | 0 <= i <= n}                                       *)
(* ------------------------------------------------------------------------------------------- *)

let rec nats_upto (n: int): int set = 
 if n < 0 then [] else n :: nats_upto (n - 1);;

(* ------------------------------------------------------------------------------------------- *)
(* power_set s liefert die Liste aller Teilmengen von s                                        *)
(* ------------------------------------------------------------------------------------------- *)

let rec power_set (s: 'a set): 'a set list = 
 match s with 
     []      -> [[]]
   | x :: s' -> 
       let p = power_set s' in 
	 List.rev_append (List.rev_map (fun s'' -> x :: s'') p) p;;
