%%
%% $Id$
%%
%% Copyright (c) 2007-2008 Christian Fehler
%% Copyright (c) 2007-2008 Benjamin Mies
%%


\chapter{Auto-Layout}\label{AutoLayout}

Beim Anlegen eines neuen Automaten, oder auch beim Modifizieren eines
bestehenden, kommt es vor, dass die Übersichtlichkeit verloren geht. Damit man
eine schnelle Möglichkeit hat, den Automaten wieder besser überblicken zu
können, wurde eine Autolayout Funktion implementiert.\vspace{10pt}

Diese Funktion basiert zur Zeit auf dem Erweiterten Partitionierungsalgorithmus
von Kerninghan und Lin. Er beruht auf der iterativen Verbesserung durch
paarweisen Austausch.\vspace{10pt}

Dieser Algorithmus wird eigentlich für die Partitionierung von Schaltungen
verwendet, kann aber problemlos auf unsere Situation übertragen werden.
Allerdings mussten bei der Übertragung einige Modifikationen
vorgenommen werden, auf welche wir später noch näher eingehen
werden.\vspace{10pt}

\section{Der Kerninghan-Lin-Algorithmus im Detail}\label{KerninghanLin}

Zu Beginn wird das Partitionierungsproblem in eine Graphendarstellung
transformiert. Danach werden die Knoten des Graphen in zwei Gruppen unterteilt.
Anschließend werden für die aktuelle Einteilung die Schnittkosten berechnet.
Zur Berechnung der Schnittkosten werden die von der Schnittlinie, die Linie, die
die beiden Gruppen trennt, erfassten Kanten gezählt.\vspace{10pt}

%### removes texlipse warning
Der Kerninghan-Lin-Algorithmus lässt sich in die folgenden Schritte
unterteilen, welche dem Buch "`Layoutsynthese elektronischer
Schaltungen"' (\cite{Layout}) entnommen wurden:\vspace{10pt}
%### removes texlipse warning

Schritt 0:
\begin{itemize}
  \item V = Menge der 2n Knoten 
  \item \{A, B\} sei eine willkürliche Anfangspartitionierung
\end{itemize}

Schritt 1:
\begin{itemize}
  \item i=1
  \item Berechnung von D(v) für alle Knoten v $\in$ V
\end{itemize}

Schritt 2:
\begin{itemize}
  \item Auswahl von $a_i$ und $b_i$ mit maximalem Gewinnwert $\Delta g_i =
  D(a_i) + D(b_i) - 2 * c(a_i b_i)$
  \item Vertauschen und fixieren von $a_i$ und $b_i$
\end{itemize}


Schritt 3:
\begin{itemize}
  \item Wenn alle Knoten fixiert sind, weiter mit Schritt 4, andernfalls
  \item Neuberechnung der D-Werte für alle Knoten, welche nicht fixiert und
  mit $a_i$ und $b_i$ verunden sind
  \item i=i+1
  \item Weiter mit Schritt 2
\end{itemize}

Schritt 4:
\begin{itemize}
  \item Bestimmung der Vertauschungssequenz 1 bis m $(1 \leq m \leq i)$, so dass
  $G_m = \sum_{i=1}^{m}{\Delta g_i}$ maximiert wird
  \item Wenn $G_m > 0$, weiter mit Schritt 5, andernfalls ENDE
\end{itemize}

Schritt 5:
\begin{itemize}
  \item Durchführen aller m Vertauschungen, beseitigen aller Knotenfixierungen
  \item Weiter mit Schritt 1
\end{itemize}\vspace{10pt}

Betrachten wir zunächst, wie der Algorithmus vorgeht, indem wir
nachvollziehen, was in den einzelnen Schritten passiert.\vspace{10pt}

In $Schritt\ 0$ wird die Knotenmenge in zwei gleichgroße Gruppen unterteilt,
wobei es keine Rolle spielt, welcher Knoten in welcher Gruppe landet. Danach wird in
$Schritt\ 1$ für alle Knoten berechnet, ob sie einen hohen oder niedrigen Anteil
der Schnittkosten verursachen. Der Gewinnwert $\Delta g$, welcher in $Schritt\
2$ erwähnt wird, beschreibt die Verbesserung der Schnittkosten, welche durch
einen Knotentausch erreicht werden kann. Die beiden Knoten, welche den
maximalen Gewinnwert bringen, werden dann getauscht und fixiert. In $Schritt\ 3$
überprüfen wir, ob alle Knoten bereits fixiert sind, ansonsten werden die Kosten
für jeden Knoten der noch nicht fixiert ist neu berechnet und erneut $Schritt\
2$ ausgeführt. In $Schritt\ 4$ wird überprüft, ob der Algorithmus bereits sein
Ende erreicht hat. Wenn nicht, werden in $Schritt\ 5$ die Vertauschungen des
aktuellen Durchgangs durchgeführt, und es wird ein neuer Durchgang gestartet.\vspace{10pt}

%### removes texlipse warning
Wie schon erwähnt musste der Algorithmus für die Implementierung ein wenig
modifiziert werden. Zum einen  geht man eigentlich davon aus, dass die
Knotenmenge in zwei ungefähr gleichgroße Gruppen einteilt. Dies erwies sich bei
der Implementierung allerdings als eher unvorteilhaft. Daher wird dynamisch
bestimmt, in wieviele Gruppen die Knoten unterteilt werden, wobei die Größe
aller Gruppen aber auch hier in etwa die gleiche ist. Diese
Implementierung entspricht soweit der Erweiterung des
Kerningham-Lin-Algorithmus wie sie in \cite{Layout} beschrieben
wird.\vspace{10pt}
%### removes texlipse warning

Die Erweiterung des Algorithmus sieht jetzt vor, dass man den Algorithmus jetzt
für alle möglichen Paarungen von Gruppen betrachtet. Die Implementierung
sieht so aus, dass man eine Linie zwischen die erste und zweite Gruppe legt, und
alle Kanten zählt, die diese Linie schneiden. Dann berechnet man, bei
welchen beiden Knoten ein Tausch die größte Verbesserung liefert, also die
meisten Schnitte mit der Linie wegfallen würden. Diese werden dann getauscht und
fixiert. Wenn alle Knoten fixiert sind, oder keine Tauschkombination existiert
bei der Schnitte mit der Linie zwischen den Gruppen wegfallen, wird die Linie
eine Gruppe nach unten geschoben, also zwischen die zweite und dritte Gruppe und
die Vorgehensweise wiederholt. Der Algorithmus terminiert, nachdem die vorletzte
und letzte Gruppe abgearbeitet wurden.\vspace{10pt}

Dieser Algorithmus liefert noch nicht das optimale Ergebnis, was daran liegt,
dass für die Kostenfunktion nur die Schnitte der Kanten berücksichtigt werden.
Daher wird im Kapitel \ref{PerspectiveAutoLayout} ein alternativer Algorithmus beschrieben,
welcher wahrscheinlich bessere Ergebnisse für ein automatisches Layout liefern
könnte.\vspace{10pt}
