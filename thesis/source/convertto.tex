%%
%% $Id$
%%
%% Copyright (c) 2007-2008 Christian Fehler
%% Copyright (c) 2007-2008 Benjamin Mies
%%


\chapter{Umwandeln}\label{ConverTo}

In diesem Kapitel soll das Umwandeln von einer Grammatik in einen Automaten
bzw. zwischen den verschiedenen Automaten Typen besprochen werden. Dabei wird
im Besonderen darauf eingegangen, welche Herausforderungen aufgetreten sind, um
dem Benutzer die verwendeten Algorithmen möglichst in kleinen Schritten und
verständlich darzustellen. Beim Umwandeln der Grammatiken in die entsprechenden
Automaten sind die verwendeten Algorithmen leicht zu verstehen und zusätzlich
nicht besonders gut darzustellen, weshalb hier darauf verzichtet wurde dem
Benutzer eine schrittweise Umwandlung anhand einer graphischen Darstellung zu
präsentieren.


\section{Grammatik umwandeln}\label{ConverToGrammar}

Wenn ein Benutzer eine Grammatik vollständig erstellt hat, kann es durchaus
interessant sein, den Automaten zu sehen, welcher die Sprache akzeptiert, die
durch die Grammatik beschrieben wird. Vor allem, da für Automaten weitaus mehr
Verwendungsmöglichkeiten in diesem Werkzeug existieren. 

\subsection{Umwandeln einer regulären Grammatik}\label{ConverToGrammarRegular}

Eine reguläre Grammatik kann in einen entsprechenden Nichtdeterministischen
endlichen Automaten umgewandelt werden. Die Zustände unseres entstehenden
Automaten resultieren aus den Nichtterminalzeichen unserer Grammatik. Allerdings
werden in der Implementierung nur Zustände für die Nichtterminalzeichen angelegt,
welche auch in einer Produktion, auf der rechten oder linken Seite, verwendet
wird. Die Zustände werden immer dann angelegt, wenn man auf ein
Nichtterminalzeichen trifft, welches man bis jetzt noch nicht gesehen
hat.\vspace{10pt}

Die Rechte Seite einer Produktion kann entweder aus einem einzelnen
Terminalzeichen bestehen($\NonterminalSymbol{S} \to \TerminalSymbol{a}$), oder
aus einem Terminalzeichen mit einem anschließenden Nichtterminalzeichen
($\NonterminalSymbol{S} \to \TerminalSymbol{a}\NonterminalSymbol{A}$). Da keine
anderen Produktionen für diese Grammatikform existieren können.\vspace{10pt}

Wir schauen uns jetzt jede Produktion unserer Grammatik an.
Zunächst interressiert uns die linke Seite. Wenn wir das Nichtterminalzeichen
bereits gesehen haben, wurde auch schon ein Zustand dafür angelegt, und wir
merken uns diesen. Wenn wir das Nichtterminalzeichen noch nicht gesehen haben,
müssen wir jetzt einen neuen Zustand anlegen, welcher dieses repräsentiert, und
merken uns diesen neuen Zustand, da dieser der Ausgangszustand
für neu enstehende Übergänge ist.\vspace{10pt}

Als nächstes betrachten wir die Rechte Seite der Produktion. Wenn es sich dabei
um ein einzelnes Terminalzeichen handelt, wird ein neuer akzeptierender Zustand
angelegt. Danach wird ein Übergang von dem Zustand für das Nichtterminalzeichen
zu diesem neuen Zustand erzeugt, wobei die Übergangsmenge aus dem
Terminalzeichen auf der rechten Seite der Produktion besteht.\vspace{10pt}

Besteht die rechte Seite allerdings aus einem Terminalzeichen und einem
Nichtterminalzeichen müssen wir wieder überprüfen, ob wir das
Nichtterminalzeichen bereits gesehen haben, um gegebenenfalls den
entsprechenden Zustand anzulegen. Im nächsten Schritt wird ein Übergang,
zwischen den beiden Zuständen die wir uns gemerkt haben, angelegt, mit dem
Terminalzeichen der rechten Seite als Übergangsmenge.\vspace{10pt}

Diese Behandlung wiederholen wir für jede Produktion unserer Grammatik und
erhalten so den entsprechenden Automaten.

\subsection{Umwandeln einer kontextfreien
Grammatik}\label{ConverToGrammarContextFree}

Der Benutzer hat auch die Möglichkeit, eine konstruierte kontextfreie Grammatik
in einen Kellerautomaten umwandeln zu lassen.\vspace{10pt}

Bei diesem Algorithmus wird zunächst ein Startzustand angelegt, welcher das
Startsymbol der Grammatik in den Keller legt. Dann wird für jede Produktion
ein Übergang angelegt, welcher die Rechte Seite der Produktion vom Keller
entfernt, und dafür die linke Seite der Produktion auf den Keller
schreibt.\vspace{10pt}

Wenn alle Produktion verarbeitet wurden, werden noch zusätzlich pro
Terminalzeichen ein Übergang angelegt. In jedem dieser Übergänge wird das
entsprechende Terminalzeichen vom Eingabewort gelesen und vom Keller des
Automaten genommen. Das bedeutet, es muss das gleiche Terminalzeichen als
oberstes im Keller  und als nächstes Zeichen im Wort stehen.\vspace{10pt}

Durch die Zweite Ansicht (siehe Kapitel \ref{SecondView}) hat der Benuzter auch
die Möglichkeit die Ausgangsgrammatik und den enstandenen Automaten nebeneinander
zu sehen, um die Zusammenhänge besser verstehen zu können.


\section{Automat umwandeln}\label{ConverToMachine}

Bei der Planung der Umwandlung zwischen den verschiedenen Automaten Typen
stellte sich die Frage, wie dem Benutzer der Umwandlungsalgorithmus möglichst
verständlich dargestellt wird. Ich entschied mich für das auch sonst im
\gtitool verwendete Verfahren, eine Navigationsleiste zu verwendet, die es dem
Benutzer gestattet in dem Algorithmus einen Schritt vor, bzw. einen Schritt
zurück zu gehen. Um die Handhabung für den Benutzer zu erleichtern, wurde die
Navigationsleiste so erweitert, dass der Benutzer zurück an den Anfang der
Ausführung des Algorithmus springen kann, ebenfalls an das Ende und, dass die
einzelnen Schritte auch automatisch, nach einer einstellbaren Zeit, durchgeführt
werden können.\vspace{10pt}

Um dem Benutzer den durchgeführten Algorithmus zu verdeutlichen, wurde die
Ansicht in drei Bereiche eingeteilt. In dem oberen linken Bereich wird der
Ausgangsautomat dargestellt, im unteren linken Bereich der nach und nach
endstehende konvertierte Automat und schließlich im rechten Bereich eine
Outline, die pro Schritt, jeweils mit einem Kommentar, angibt, welchen Schritt
der Algorithmus im Moment durchführt.\vspace{10pt}

\begin{figure}[h!]
\begin{center}
\includegraphics[width=12cm]{../images/convert_to.png}
\caption{Automat umwandeln}
\end{center}
\end{figure}

Es existieren zwei verschiedene Verfahren zur Umwandlung in einen
deterministischen endlichen Automaten (DEA). Zum einen kann der komplette
Potenzautomat verwendet werden, um den DEA zu erzeugen. Der entstehende Automat
enthält allerdings unter Umständen sehr viele nicht erreichbare Zustände, deren
Berechnung einige zusätzliche Schritte zur Folge haben. Wenn der Benutzer diese
Art der Umwandlung auswählt, kann er nach dem Umwandeln die nicht erreichbaren
Zustände wieder entfernen, wie dies funktioniert, kann in \ref{ReachableStates}
nachgelesen werden. Die zweite Methode ist, dass nur die erreichbaren Zustände
in der unteren Ansicht angelegt werden. Diese Methode ist übersichtlicher für
den Benutzer, wenn auch nicht alle im Potenzautomaten vorhandenen Zustände
betrachtet werden.\vspace{10pt}

%### removes texlipse warning
Zur Umsetzung wurde der in \cite[S. 153ff]{Compilers} angegebene Algorithmus als
Vorlage benutzt. Um den Algorithmus verwenden zu können, müssen zuerst einige
Werte definiert werden.\vspace{10pt}
%### removes texlipse warning

\noindent
\begin{tabular}{|p{2.2cm}|p{9.0cm}|}
  \hline
  NFA A                 & Input NFA \\
  \hline
  DFA D                 & Output DFA \\
  \hline
  Dstates               & States of output DFA D \\
  \hline
  Dtran                 & Transition function of DFA D \\
  \hline
  $\epsilon$-closure(s) & Set of NFA states reachable from NFA state s
                          on $\epsilon$-transitions alone \\
  \hline
  $\epsilon$-closure(T) & Set of NFA states reachable from some NFA state s
                          in set T on $\epsilon$-transitions alone; =
                          $\cup_{s\ in\ T}\ \epsilon$-closure(s). \\
  \hline
  move(T,a)             & Set of NFA states to which there is a transition
                          on input symbol a from some state s in T \\
  \hline
\end{tabular}
\vspace{10pt}

Die eigentliche Umwandlung geschieht dann mit folgendem Algorithmus, der aus
didaktischen Gründen in mehrere Schritte aufgeteilt wurde.\vspace{10pt}

\noindent
\verb|initially, |$\epsilon$\verb|-closure(|$s_0$\verb|) is the only state in Dstates,|\\
\verb|and it is unmarked;|\\
\verb|while ( there is an unmarked state T in Dstates ) {|\\
\verb|      mark T;|\\
\verb|      for ( each input symbol a ) {|\\
\verb|          U = |$\epsilon$\verb|-closure(move(T,a));|\\
\verb|          if ( U is not in Dstates )|\\
\verb|             add U as an unmarked state to Dstates;|\\
\verb|          Dtran[T,a] = U;|\\
\verb|      }|\\
\verb|}|
