%%
%% $Id$
%%
%% Copyright (c) 2007-2008 Christian Fehler
%% Copyright (c) 2007-2008 Benjamin Mies
%%


\chapter{Automaten}\label{Machines}


\section{Graphenansicht}


\subsection{Automatendarstellung mit JGraph}

Bei der Darstellung der Automaten haben wir uns sehr an dem aktuellen
Vorlesungsskript orientiert. Wir wollten eine möglichst hohe Überdeckung
erreichen, um sicherzustellen, dass ein Benutzer einen existierenden Automaten
verstehen kann, ohne sich noch viel einlesen zu müssen. In den
Vorlesungsunterlagen wird ein Zustand als Kreis
dargestellt. Ein Startzustand wird über einen doppelten Rahmen gekennzeichnet
und ein Startzustand erkennt man an einem Pfeil, der optional mit Start
beschriftet sein kann.\vspace{10pt}

\begin{figure}[h!]
\begin{center}
\includegraphics[width=12cm]{../images/enfa_example.png}
\caption{Beispiel für eine Automatendarstellung mit JGraph}
\end{center}
\end{figure}

Um dies zu realisieren haben wir uns die frei verfübare Java Bibliothek JGraph
zunutze gemacht, und nach unseren Bedürfnissen angepasst. Als erstes mussten
wir mit Hilfe von JGraph Komponenten ein geeignete Darstellung von Zuständen
und Übergängen erreichen. Diese Komponenten mussten dynamisch angelegt,
gelöscht und bearbeitet werden können. Nachdem wir also eine passende
Darstellung für unsere Automaten gefunden hatten, mussten wir noch die
Verknüpfung von den grafischen Elementen und den Kernelementen herstellen. Um
eine eindeutige Zuweisung von diesen Elementen zu erreichen, haben wir uns dazu
entschieden, die Kernelemente als Attribut in den grafischen Komponenten.\vspace{10pt}

Nachdem die Verknüpfung der Komponenten erledigt war, konnte man die
Darstellung der Zustände und Übergänge anhand der entsprechenden Daten
anpassen. Das bedeutet für Zustände, das man den Namen des Zustandsobjekts
anzeigt, und auch auswertet, ob es sich um einen Startzustand oder Endzustand
handelt. Bei den Übergängen konnte die Übergangsmenge als Beschriftung benutzt
werden, wie es bei der Vorlage im Skript auch der Fall ist.\vspace{10pt}



\subsection{Anpassung von JGraph}

TODOCF


\section{Tabellen}

In diesem Abschnitt werden die zwei Tabellen beschrieben, die bei den Automaten
verwendet werden, um dem Benutzer zusätzliche Informationen zur Verfügung zu
stellen. Die Übergangstabelle bietet zusätzlich noch die Möglichkeit den
Automaten zu verändern. Es können Übergänge angelegt, modifiziert oder gelöscht
werden.


\subsection{Übergangstabelle}

Während der Entwicklung und ersten Tests des \gtitools kam der Wunsch auf,
einen Automaten nicht nur graphisch zu bearbeiten, sondern auch in der
Übergangstabelle. Dadurch soll es dem Benutzer ermöglicht werden, Übergänge
schneller anzulegen, als es bei der normaler Methode in der Graphenansicht der
Fall wäre. Um diese neue Methode zu implementieren wurden einige verschiedene
Umsetzungen diskutiert. Zur Diskusion standen unter anderen, dass in jeder
Zelle der Tabelle ausgewählt werden kann, zu welchen Zuständen ein Übergang
existiert. Diese Auswahl hätte allerdings bei der Umsetzung schlecht
ausgesehen, zumindest bei hinreichend vielen Zuständen. Aus diesem Grund wurde
dieser Ansatz verworfen.\vspace{10pt}

\begin{figure}[h!]
\begin{center}
\includegraphics[width=12cm]{../images/machine_table.png}
\caption{Übergangstabelle}
\end{center}
\end{figure}

Als nächste mögliche Umsetzung wurde diskutiert, ob es technisch möglich sei,
in jede Zelle einen Parser zu verwenden. Dieser Parser musste so implementiert
werden, dass er einen oder mehrere, durch Komma getrennte Zustände als Eingabe
akzeptiert. Im Kapitel \ref{Parser} werden einige kontextsensitive Bedingungen
angesprochen, die auch bei dem hier vorliegenden Parser verwendet werden
mussten, da es dem Benutzer nicht möglich sein sollte, einen oder mehrere
Zustände anzugeben, die nicht im Graphen vorkommen. Der Parser als solches
konnte leicht implementiert werden, es gab allerdings einige technische
Probleme diesen in jede Zelle zu implementieren. Diese Probleme konnten gelöst
werden, so dass der Benutzer nun in der Lage ist, Übergänge per Tabelle
anzulegen, zu modifizieren und zu löschen.


\subsection{Keller Operationen Tabelle}

Anhand der Tabelle für Kelleroperationen kann der User genau nachvollziehen,
was genau mit unserem Keller passiert, wenn wir mit diesem
Übergang in einen anderen Zustand übergehen.\vspace{10pt}

Die Tabelle enthält einen Eintrag pro Übergang in unserem Automaten. Jeder
Eintrag enthält den Zustand von dem der Übergang ausgeht, den Zustand zu dem
wir übergehen und die entsprechende Übergangsmenge. Zusätzlich wird noch
das Wort angegeben, welches bei diesem Übergang vom Keller gelesen wird, und
das Wort, welches auf den Keller geschrieben wird. Wenn wir nichts von dem
Keller lesen oder auf den Keller schreiben wird als Wort $\epsilon$
verwendet.\vspace{10pt}

\begin{figure}[h!]
\begin{center}
\includegraphics[width=8cm]{../images/stack_operation_table.png}
\caption{Keller Operationen Tabelle}
\end{center}
\end{figure}

Als Orientierungshilft für den Benutzer kann man einen Eintrag in der Tabelle
auswählen, und es wird dann der entsprechende Übergang im Automaten farblich
hervorgehoben. Dies soll dabei helfen die Funktionsweise des aktuellen
Automaten nachzuvollziehen.\vspace{10pt}


\section{Wort-Navigation}


\subsection{Deterministische Navigation}

Wir wollten dem Nutzer auch die Möglichkeit geben, sich anzusehen, wie der
konstruierte Automat ein beliebiges Eingabewort abarbeitet. Für diesen Zweck
wurde die Wortnavigation entwickelt.\vspace{10pt}

Wenn der Nutzer den Wortnavigationsmodus startet findet er am unteren
Bildschirmrand zwei Textfelder. Dabei handelt es sich um ein Eingabefeld für
das Eingabewort, und um eine Anzeige des aktuellen Kellers. In der
deterministischen Wortnavigation spielt die Kelleranzeige keine Rolle. Diese
wird allerdings im folgenden Kapitel benötigt, und dann auch näher erläutert
werden.\vspace{10pt}

Um den Benutzer eine Hilfestellung bei der Eingabe eines Wortes zu geben, wird
rechts neben dem Eingabefeld das aktuelle Alphabet angezeigt. Man kann nur
Symbole verwenden, welche auch im aktuellen Alphabet enthalten
sind.\vspace{10pt}

  \begin{figure}[h]
  \begin{center}
  \includegraphics[width=12cm]{../images/dfa_navigation.png}
  \caption{Automat - Wortnavigation}
  \end{center}
  \end{figure}

Nachdem ein Wort eingegeben wurde kann der Nutzer dann die Verarbeitung des
Worts starten. Es besteht die Möglichkeit sich Symbol für Symbol weiter durch
das Wort zu arbeiten, und den genauen Weg im Automaten nachzuvollziehen. Um
Verständnisprobleme besser beseitigen zu können, ist auch hier eine Navigation
in Vor- und Rückrichtung möglich.\vspace{10pt}
\vspace{10pt}

Für jeden Schritt werden die Zustände farblich hervorgehoben, in denen sich der
Automat aktuell befindet. Zusätzlich wird auch der Übergang und das
entsprechende Symbol des Übergangs hervorgehoben, über welchen man in diesen
Zustand gekommen ist. In dem Feld, in welchem man das Wort eingegeben hat, wird
jetzt angezeigt, bis zu welcher Stelle der Automat das Wort schon verarbeitet
hat.\vspace{10pt}

Wenn man das ganze Wort verarbeitet hat bekommt der Benutzer eine Information,
ob der Automat das Wort akzeptiert hat, oder ob das Wort nicht in der Sprache
des Automaten liegt.\vspace{10pt}


\subsection{Zustands Pfad}

Bei Verwendung eines nicht deterministischen Automaten stellte sich bei der
Wort Navigation die Frage, auf welchem Pfad die aktuell aktiven Zustände
erreicht wurden. Es wurden verschiedene Umsetzungen in Betracht gezogen, dem
Benutzer die Ausgabe darzustellen. Es wurde schließlich entschieden, die
Zustände auf dem Weg zu den aktuell aktiven Zuständen darzustellen. Zwischen
diesen Zuständen werden die verwendeten Übergänge, sowie die verwendeten
Symbole an den Übergängen dargestellt, bzw. hervorgehoben. Da unter Umständen
viele Zustands Pfade vorhanden sein können, werden diese anhand der Anzahl der
verwendeten Zustände sortiert, somit werden die kürzesten Pfade zuerst
angezeigt.\vspace{10pt}

\begin{figure}[h!]
\begin{center}
\includegraphics[width=12cm]{../images/history_path.png}
\caption{Zustands Pfad}
\end{center}
\end{figure}

Der implementierte Algorithmus geht rückwärts vor, startet also bei den aktuell
aktiven Zuständen und geht alle Pfade zurück, bis alle, bis jetzt gelesenen
Symbole abgearbeitet sind. Startet der berechnete Pfad dann in dem
Startzustand, wurde ein gültiger Pfad erkannt. Bei der Implementierung des
Algorithmus musste eine Zykluserkennung umgesetzt werden, da es sonst möglich
war in eine Endlosschleife zu geraten, welche durch $\epsilon$-Übergänge
verursacht wurde.


\section{Erreichbare Zustände}\label{ReachableStates}

Nach dem in \ref{ConverToMachine} nachzulesenen Umwandeln eines nicht
deterministischen in einen deterministischen Automaten unter Verwendung der
Potenzautomatenkonstruktion stellte sich die Frage, wie die nicht erreichbaren
Zustände erkannt und entfernt werden können. Dieses Problem betrifft aber nicht
nur umgewandelte Automaten, sondern ganz allgemein, jeden erstellten
Automaten.\vspace{10pt}

Bei der Umsetzung sollte im Vordergrund stehen, dass der Benutzer mit sehr
kleinen Schritten verdeutlicht bekommt, wie der zugrunde liegende Algorithmus
arbeitet, so dass diese Arbeitsweise sehr einfach nachzuvollziehen
ist.\vspace{10pt}

\begin{figure}[h!]
\begin{center}
\includegraphics[width=12cm]{../images/reachable_states.png}
\caption{Erreichbare Zustände}
\end{center}
\end{figure}

Der verwendete Algorithmus besteht aus drei Phasen. In der ersten Phase wird ein
noch nicht abgearbeiteter Zustand ausgewählt, zu Beginn wird mit dem Startzustand
begonnen. In der zweiten Phase werden die von diesem Zustand aus direkt
erreichbaren Zustände berechnet und dem Benutzer hervorgehoben dargestellt. In
der dritten Phase werden alle bis jetzt zu erreichenden Zustände hervorgehoben.
Gleichzeitig bekommt der Benutzer in der Outline mitgeteilt, welcher Zustand
jetzt fertiggestellt ist und welche noch berechnet werden müssen. Durch diese
sehr feine Unterteilung, soll ein besseres Verständnis des Algorithmus erreicht
werden.
