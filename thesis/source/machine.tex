%%
%% $Id$
%%
%% Copyright (c) 2007-2008 Christian Fehler
%% Copyright (c) 2007-2008 Benjamin Mies
%%


\chapter{Automaten}\label{Machines}

Im Mittelpunkt der Planung und der Umsetzung des \gtitools standen die
Automaten. Die verschiedenen Aspekte von Automaten werden in diesem Kapitel
besprochen, dazu behört die graphische Umsetzung, sowie die verschiedenen
Möglichkeiten, was mit einem Automaten geschehen kann, wenn dieser angelegt
wurde.


\section{Graphenansicht}\label{Graph}

In diesem Abschnitt wird die Graphendarstellung besprochen. Zu Beginn der
Diplomarbeit wurde diskutiert, welche Möglichkeiten zur Darstellung eines
Automaten zur Verfügung stehen. Im Raum standen das eigenständige
Implementieren der graphischen Komponenten, sowie das Benutzen einer
Bibliothek, die diese Funktionalität zur Verfügung stellt. Aufgrund des
vermutlich enormen Zeitaufwand wurde entschieden, eine Bibliothek zu benutzen.
In Abschnit \ref{PerspectiveGraphics} wird darauf eingegangen, in wie weit eine
Änderung in Zukunft sinnvoll, bzw. realisierbar ist.\vspace{10pt} 

Da JGraph (siehe \gticite{jgraph}) die Funktionalität zur Verfügung stellt, die
wir brauchen, um die Automaten darstellen zu können, wurde entschieden, diese
Bibliothek zu benutzen. Im folgenden wird darauf eingegangen, wie Automaten mit
JGraph dargestellt werden und wie JGraph angepasst werden musste, um den
speziellen Ansprüchen unserer Umsetzung zu genügen.


\subsection{Automatendarstellung mit JGraph}\label{GraphJGraph}

Bei der Darstellung der Automaten haben wir uns sehr an dem aktuellen
Vorlesungsskript orientiert. Wir wollten eine möglichst hohe Überdeckung
erreichen, um sicherzustellen, dass ein Benutzer einen existierenden Automaten
verstehen kann, ohne sich noch viel einlesen zu müssen. In den
Vorlesungsunterlagen wird ein Zustand als Kreis dargestellt. Ein Startzustand
wird über einen doppelten Rahmen gekennzeichnet und ein Startzustand erkennt man
an einem Pfeil, der optional mit Start beschriftet sein kann.\vspace{10pt}

\begin{figure}[h!]
\begin{center}
\includegraphics[width=12cm]{../images/enfa_example.png}
\caption{Beispiel für eine Automatendarstellung mit JGraph}
\end{center}
\end{figure}

Um dies zu realisieren haben wir uns die frei verfübare Java Bibliothek JGraph
zunutze gemacht, und nach unseren Bedürfnissen angepasst. Als erstes mussten
wir mit Hilfe von JGraph Komponenten ein geeignete Darstellung von Zuständen
und Übergängen erreichen. Diese Komponenten mussten dynamisch angelegt,
gelöscht und bearbeitet werden können. Nachdem wir also eine passende
Darstellung für unsere Automaten gefunden hatten, mussten wir noch die
Verknüpfung von den graphischen Elementen und den Kernelementen herstellen. Um
eine eindeutige Zuweisung von diesen Elementen zu erreichen, haben wir uns dazu
entschieden, die Kernelemente als Attribut in den grafischen Komponenten
zu speichern.\vspace{10pt}

Nachdem die Verknüpfung der Komponenten erledigt war, konnte man die
Darstellung der Zustände und Übergänge anhand der entsprechenden Daten
anpassen. Das bedeutet für Zustände, das man den Namen des Zustandsobjekts
anzeigt, und auch auswertet, ob es sich um einen Startzustand oder Endzustand
handelt. Bei den Übergängen konnte die Übergangsmenge als Beschriftung benutzt
werden, wie es bei der Vorlage im Skript auch der Fall ist.\vspace{10pt}


\subsection{Anpassung von JGraph}\label{GraphJGraphAdaptation}

Die Bibliothek JGraph bietet einen weit über unsere Anforderungen hinaus
gehende Unterstützung von graphischen Komponenten. An einigen Stellen mussten
allerdings Anpassungen vorgenommen werden, um den von uns vorgegebenen
Funktionumfang erreichen zu können. Diese Anpassungen werden in diesem
Abschnitt besprochen.\vspace{10pt}

Als erste Anpassung wurde umgesetzt, dass die Farbe der Zustände geändert
werden kann. Dies wird zwar von der Bibliothek unterstützt, allerdings wurde
von uns eine Verknüpfung mit den Kernelementen gewünscht. Auf diese Weise ist
es nun möglich einem solchem Kernelement zu sagen, dass es aktiv oder
fehlerhaft ist. Die graphische Komponente aktualisiert sich dann beim nächsten
Zeichnen automatisch. Durch diese Art der Implementierung ist es jetzt sehr
einfach in den verschiedenen Algorithmen die Darstellung der graphischen
Komponenten zu beeinflussen.\vspace{10pt}

Eine weitere Anpassung die von uns implementiert wurde, ist die schon von den
Parsern, siehe Kapitel \ref{Parser}, bekannte Verwendung von sogenannten
PrettyStrings. Bei einfachen Übergängen oder Zuständen mit kurzem Namen,
beinhaltet diese Anpassung nicht allzu viele Verbesserungen. Das sieht aber bei
der Verwendung von mehreren Symbolen in einem Übergang oder den
Potenzmengen-Zuständen anders aus. Dort ist der Benutzer in der Lage durch die
zusätzlichen Farbinformation und Zeichenattribute die ihm zur Verfügung
gestellten Informationen schneller aufzunehmen, als wenn ihm eine unformatierte
Zeichenkette angezeigt werden würde.\vspace{10pt}

In Kapitel \ref{ConverTo} wird die Umwandlung von Automaten in andere Automaten
Formen, z.B. die Umwandlung von einem $\epsilon$-NDEA in einen DEA. Bei der
Implementierung dieser Umwandlung wurden wir vor das Problem gestellt, dass in
der Literatur, sowie im Vorlesungsskript Potenzautomaten-Zustand nicht rund
dargestellt werden, sondern als Rechteck mit abgerundeten Ecken. Dieses Problem
wurde durch die Anpassung der graphischen Zustände, sowie durch die Berechnung
der Endpunkte der Übergänge gelöst.\vspace{10pt}

Die Darstellungsweise von parallelen Übergängen in entgegengesetzte Richtung
musste angepasst werden, da die normale Implementierung ein Ergebnis lieferte,
das dem als Vorlage benutzten Beispiel im Vorlesungsscript nicht ähnlich
war.\vspace{10pt}

Die letzte wichtige Anpassung wurde notwendig, da ein Start-Zustand mit einem
Pfeil auf den Zustand dargestellt werden musste. Dieser graphische Pfeil musste
somit zu dem Zustand gehören, was die Breite des Zustandes erhöhte und damit
die normale Berechnung von JGraph, zum Beispiel die Berechnung der Position
eines Überganges beeinflusste und dafür sorgte, dass der Graph nicht mehr so
aussah, wie er intuitiv sein sollte. Um dieses Problem zu lösen, musste bei
vielen Berechnungen, ein Offset berücksichtigt werden, so dass ein
Start-Zustand nicht mehr anders behandelt wurde, wie ein normaler
Zustand.\vspace{10pt}


\section{Tabellen}

In diesem Abschnitt werden die zwei Tabellen beschrieben, die bei den Automaten
verwendet werden, um dem Benutzer zusätzliche Informationen zur Verfügung zu
stellen. Die Übergangstabelle bietet zusätzlich noch die Möglichkeit den
Automaten zu verändern. Es können Übergänge angelegt, modifiziert oder gelöscht
werden.


\subsection{Übergangstabelle}

Während der Entwicklung und ersten Tests des \gtitools kam der Wunsch auf,
einen Automaten nicht nur graphisch zu bearbeiten, sondern auch in der
Übergangstabelle. Dadurch soll es dem Benutzer ermöglicht werden, Übergänge
schneller anzulegen, als es bei der normaler Methode in der Graphenansicht der
Fall wäre. Um diese neue Methode zu implementieren wurden einige verschiedene
Umsetzungen diskutiert. Zur Diskusion standen unter anderen, dass in jeder
Zelle der Tabelle ausgewählt werden kann, zu welchen Zuständen ein Übergang
existiert. Diese Auswahl hätte allerdings bei der Umsetzung schlecht
ausgesehen, zumindest bei hinreichend vielen Zuständen. Aus diesem Grund wurde
dieser Ansatz verworfen.\vspace{10pt}

\begin{figure}[h!]
\begin{center}
\includegraphics[width=12cm]{../images/machine_table.png}
\caption{Übergangstabelle}
\end{center}
\end{figure}

Als nächste mögliche Umsetzung wurde diskutiert, ob es technisch möglich sei,
in jede Zelle einen Parser zu verwenden. Dieser Parser musste so implementiert
werden, dass er einen oder mehrere, durch Komma getrennte Zustände als Eingabe
akzeptiert. Im Kapitel \ref{Parser} werden einige kontextsensitive Bedingungen
angesprochen, die auch bei dem hier vorliegenden Parser verwendet werden
mussten, da es dem Benutzer nicht möglich sein sollte, einen oder mehrere
Zustände anzugeben, die nicht im Graphen vorkommen. Der Parser als solches
konnte leicht implementiert werden, es gab allerdings einige technische
Probleme diesen in jede Zelle zu implementieren. Diese Probleme konnten gelöst
werden, so dass der Benutzer nun in der Lage ist, Übergänge per Tabelle
anzulegen, zu modifizieren und zu löschen.


\subsection{Keller Operationen Tabelle}

Anhand der Tabelle für Kelleroperationen kann der User genau nachvollziehen,
was genau mit unserem Keller passiert, wenn wir mit diesem
Übergang in einen anderen Zustand übergehen.

\begin{figure}[h!]
\begin{center}
\includegraphics[width=12cm]{../images/stack_operation_table.png}
\caption{Keller Operationen Tabelle}
\end{center}
\end{figure}

Die Tabelle enthält einen Eintrag pro Übergang in unserem Automaten. Jeder
Eintrag enthält den Zustand von dem der Übergang ausgeht, den Zustand zu dem
wir übergehen und die entsprechende Übergangsmenge. Zusätzlich wird noch
das Wort angegeben, welches bei diesem Übergang vom Keller gelesen wird, und
das Wort, welches auf den Keller geschrieben wird. Wenn wir nichts von dem
Keller lesen oder auf den Keller schreiben wird als Wort $\epsilon$
verwendet.\vspace{10pt} 

Als Orientierungshilft für den Benutzer kann man einen Eintrag in der Tabelle
auswählen, und es wird dann der entsprechende Übergang im Automaten farblich
hervorgehoben. Dies soll dabei helfen die Funktionsweise des aktuellen
Automaten nachzuvollziehen.\vspace{10pt}


\section{Wort-Navigation}\label{wordNavigation}


\subsection{Deterministische Navigation}

Wir wollten dem Nutzer auch die Möglichkeit geben, sich anzusehen, wie der
konstruierte Automat ein beliebiges Eingabewort abarbeitet. Für diesen Zweck
wurde die Wortnavigation entwickelt.\vspace{10pt}

Wenn der Nutzer den Wortnavigationsmodus startet findet er am unteren
Bildschirmrand zwei Textfelder. Dabei handelt es sich um ein Eingabefeld für
das Eingabewort, und um eine Anzeige des aktuellen Kellers. In der
deterministischen Wortnavigation spielt die Kelleranzeige keine Rolle. Diese
wird allerdings im folgenden Kapitel benötigt, und dann auch näher erläutert
werden.\vspace{10pt}

Um den Benutzer eine Hilfestellung bei der Eingabe eines Wortes zu geben, wird
rechts neben dem Eingabefeld das aktuelle Alphabet angezeigt. Man kann nur
Symbole verwenden, welche auch im aktuellen Alphabet enthalten
sind.\vspace{10pt}

  \begin{figure}[h]
  \begin{center}
  \includegraphics[width=12cm]{../images/dfa_navigation.png}
  \caption{Automat - Wortnavigation}
  \end{center}
  \end{figure}

Nachdem ein Wort eingegeben wurde kann der Nutzer dann die Verarbeitung des
Worts starten. Es besteht die Möglichkeit sich Symbol für Symbol weiter durch
das Wort zu arbeiten, und den genauen Weg im Automaten nachzuvollziehen. Um
Verständnisprobleme besser beseitigen zu können, ist auch hier eine Navigation
in Vor- und Rückrichtung möglich.\vspace{10pt}
\vspace{10pt}

Für jeden Schritt werden die Zustände farblich hervorgehoben, in denen sich der
Automat aktuell befindet. Zusätzlich wird auch der Übergang und das
entsprechende Symbol des Übergangs hervorgehoben, über welchen man in diesen
Zustand gekommen ist. In dem Feld, in welchem man das Wort eingegeben hat, wird
jetzt angezeigt, bis zu welcher Stelle der Automat das Wort schon verarbeitet
hat.\vspace{10pt}

Wenn man das ganze Wort verarbeitet hat bekommt der Benutzer eine Information,
ob der Automat das Wort akzeptiert hat, oder ob das Wort nicht in der Sprache
des Automaten liegt.\vspace{10pt}


\subsection{Zustands Pfad}

Bei Verwendung eines nicht deterministischen Automaten stellte sich bei der
Wort Navigation die Frage, auf welchem Pfad die aktuell aktiven Zustände
erreicht wurden. Es wurden verschiedene Umsetzungen in Betracht gezogen, dem
Benutzer die Ausgabe darzustellen. Es wurde schließlich entschieden, die
Zustände auf dem Weg zu den aktuell aktiven Zuständen darzustellen. Zwischen
diesen Zuständen werden die verwendeten Übergänge, sowie die verwendeten
Symbole an den Übergängen dargestellt, bzw. hervorgehoben. Da unter Umständen
viele Zustands Pfade vorhanden sein können, werden diese anhand der Anzahl der
verwendeten Zustände sortiert, somit werden die kürzesten Pfade zuerst
angezeigt.\vspace{10pt}

\begin{figure}[h!]
\begin{center}
\includegraphics[width=12cm]{../images/history_path.png}
\caption{Zustands Pfad}
\end{center}
\end{figure}

Der implementierte Algorithmus geht rückwärts vor, startet also bei den aktuell
aktiven Zuständen und geht alle Pfade zurück, bis alle, bis jetzt gelesenen
Symbole abgearbeitet sind. Startet der berechnete Pfad dann in dem
Startzustand, wurde ein gültiger Pfad erkannt. Bei der Implementierung des
Algorithmus musste eine Zykluserkennung umgesetzt werden, da es sonst möglich
war in eine Endlosschleife zu geraten, welche durch $\epsilon$-Übergänge
verursacht wurde.


\section{Erreichbare Zustände}\label{ReachableStates}

Nach dem in \ref{ConverToMachine} nachzulesenen Umwandeln eines nicht
deterministischen in einen deterministischen Automaten unter Verwendung der
Potenzautomatenkonstruktion stellte sich die Frage, wie die nicht erreichbaren
Zustände erkannt und entfernt werden können. Dieses Problem betrifft aber nicht
nur umgewandelte Automaten, sondern ganz allgemein, jeden erstellten
Automaten.\vspace{10pt}

Bei der Umsetzung sollte im Vordergrund stehen, dass der Benutzer mit sehr
kleinen Schritten verdeutlicht bekommt, wie der zugrunde liegende Algorithmus
arbeitet, so dass diese Arbeitsweise sehr einfach nachzuvollziehen
ist.\vspace{10pt}

Zur Umsetzung wurde der in \gticitepage{Algorithmen}{536} angegebene Algorithmus
als Vorlage benutzt. Dieser Algorithmus implementiert die Breitensuche auf
einem Graphen G mit Startknoten s. Zur Interpretation des Algorithmus ist noch
zu sagen, dass das Attribut Farbe eines Knoten dazu verwendet wird, zu
speichern in welchem Phase des Algorithmus er sich befindet. Ist ein Knoten
weiss, bedeutet das, dass er noch nicht erkannt wurde. Am Anfang sind alle
Knoten, außer dem Startknoten weiss. Grau bedeutet, dass der Knoten erkannt
wurde, aber noch nicht vollständig abgearbeitet wurde. Wurde ein Knoten
abgearbeitet, ändert sich seine Farbe in schwarz. Bei der Umsetzung im \gtitool
wurde eine ähnliche Umsetzung gewählt, die nun besprochen wird.\vspace{10pt}

\newpage
\noindent
\verb|BFS(G,s)|\\
\verb|for alle Knoten u |$\in$\verb| V[G] - {s}|\\
\verb|    do farbe[u] |$\gets$\verb| WEISS|\\
\verb|       d[u] |$\gets \infty$\\
\verb|       |$\pi$\verb|[u] |$\gets$\verb| NIL|\\
\verb|farbe[s] |$\gets$\verb| GRAU|\\
\verb|d[s] |$\gets$\verb| 0|\\
\verb||$\pi$\verb|[s] |$\gets$\verb| NIL|\\
\verb|Q |$\gets \emptyset$\\
\verb|ENQUEUE(Q,s)|\\
\verb|while Q |$\neq \emptyset$\\
\verb|      do u |$\gets$\verb| DEQUEUE(Q)|\\
\verb|         for alle v |$\in$\verb| Adj[u]|\\
\verb|             do if farbe[v] = WEISS|\\
\verb|                   then farbe[v] |$\gets$\verb| GRAU|\\
\verb|                        d[v] |$\gets$\verb| d[u] + 1|\\
\verb|                        |$\pi$\verb|[v] |$\gets$\verb| u|\\
\verb|                        ENQUEUE(Q,v)|\\
\verb|         farbe[u] |$\gets$\verb| SCHWARZ|\\
\vspace{10pt}

Der dann im Programm umgesetzte Algorithmus besteht aus drei Phasen. In der
ersten Phase wird ein noch nicht abgearbeiteter Zustand ausgewählt, zu Beginn
wird mit dem Startzustand begonnen. In der zweiten Phase werden die von diesem
Zustand aus direkt erreichbaren Zustände berechnet und dem Benutzer hervorgehoben
dargestellt. In der dritten Phase werden alle bis jetzt zu erreichenden Zustände
hervorgehoben. Gleichzeitig bekommt der Benutzer in der Outline mitgeteilt,
welcher Zustand jetzt fertiggestellt ist und welche noch berechnet werden müssen.
Durch diese sehr feine Unterteilung, soll ein besseres Verständnis des
Algorithmus erreicht werden.

\begin{figure}[h!]
\begin{center}
\includegraphics[width=12cm]{../images/reachable_states.png}
\caption{Erreichbare Zustände}
\end{center}
\end{figure}
